<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ratul's Portfolio - Welcome</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;400;500;600;700&family=Chakra+Petch:wght@300;400;500;600;700&family=Audiowide&family=Fredoka+One&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/framer-motion@10.16.4/dist/framer-motion.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            font-family: 'Chakra Petch', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        }

        .container {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: #000000;
        }

        .beams-container {
            position: absolute;
            inset: 0;
            display: flex;
            height: 100%;
            width: 100%;
            align-items: center;
            justify-content: center;
            mask-repeat: no-repeat;
            mask-size: 40px;
            z-index: 1;
        }
        
        .beams-svg {
            pointer-events: none;
            position: absolute;
            z-index: 1;
            height: 100%;
            width: 100%;
        }

        .canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
        }

        .content {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: none;
            z-index: 10;
        }

        .greeting {
            position: absolute;
            top: 12%;
            left: 15%;
            font-family: 'Fredoka One', cursive;
            font-size: 2.5rem;
            font-weight: 400;
            color: #ffffff;
            letter-spacing: 3px;
        }

        .intro {
            position: absolute;
            top: 25%;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Fredoka One', cursive;
            font-size: 2.5rem;
            font-weight: 400;
            color: #ffffff;
            letter-spacing: 2px;
        }

        .name {
            font-family: 'Fredoka One', cursive;
            font-size: 12rem;
            font-weight: 400;
            color: #ffffff;
            text-align: center;
            letter-spacing: 8px;
            margin: 2rem 0;
        }

        .welcome {
            font-family: 'Fredoka One', cursive;
            font-size: 2.5rem;
            font-weight: 400;
            color: #ffffff;
            max-width: 50rem;
            padding: 0 2rem;
            line-height: 1.6;
            text-align: center;
            letter-spacing: 1px;
            margin-top: 2rem;
        }

        @media (max-width: 768px) {
            .greeting {
                font-size: 2rem;
                letter-spacing: 2px;
                top: 3%;
                left: 5%;
            }
            
            .intro {
                font-size: 2rem;
                top: 30%;
            }
            
            .name {
                font-size: 8rem;
                letter-spacing: 4px;
                margin: 1.5rem 0;
            }
            
            .welcome {
                font-size: 2rem;
                padding: 0 1.5rem;
            }
        }

        @media (max-width: 480px) {
            .greeting {
                font-size: 1.5rem;
                top: 2%;
                left: 3%;
            }
            
            .intro {
                font-size: 1.5rem;
                top: 25%;
            }
            
            .name {
                font-size: 5rem;
                letter-spacing: 2px;
            }
            
            .welcome {
                font-size: 1.5rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="beams-container" id="beams-container"></div>
        <div class="canvas-container" id="canvas-container"></div>
        <div class="content">
            <div class="greeting">Hlw everyone !!</div>
            <div class="intro">I am</div>
            <div class="name">RATUL</div>
            <div class="welcome">Welcome to my portfolio</div>
        </div>
    </div>

    <script type="text/babel">
        const { memo, useMemo } = React;
        const { motion } = Motion;

        const BackgroundBeams = memo(({ className }) => {
            const paths = useMemo(() => [
                "M-380 -189C-380 -189 -312 216 152 343C616 470 684 875 684 875",
                "M-373 -197C-373 -197 -305 208 159 335C623 462 691 867 691 867",
                "M-366 -205C-366 -205 -298 200 166 327C630 454 698 859 698 859",
                "M-359 -213C-359 -213 -291 192 173 319C637 446 705 851 705 851",
                "M-352 -221C-352 -221 -284 184 180 311C644 438 712 843 712 843",
                "M-345 -229C-345 -229 -277 176 187 303C651 430 719 835 719 835",
                "M-338 -237C-338 -237 -270 168 194 295C658 422 726 827 726 827",
                "M-331 -245C-331 -245 -263 160 201 287C665 414 733 819 733 819",
                "M-324 -253C-324 -253 -256 152 208 279C672 406 740 811 740 811",
                "M-317 -261C-317 -261 -249 144 215 271C679 398 747 803 747 803",
                "M-310 -269C-310 -269 -242 136 222 263C686 390 754 795 754 795",
                "M-303 -277C-303 -277 -235 128 229 255C693 382 761 787 761 787",
                "M-296 -285C-296 -285 -228 120 236 247C700 374 768 779 768 779",
                "M-289 -293C-289 -293 -221 112 243 239C707 366 775 771 775 771",
                "M-282 -301C-282 -301 -214 104 250 231C714 358 782 763 782 763",
                "M-275 -309C-275 -309 -207 96 257 223C721 350 789 755 789 755",
                "M-268 -317C-268 -317 -200 88 264 215C728 342 796 747 796 747",
                "M-261 -325C-261 -325 -193 80 271 207C735 334 803 739 803 739",
                "M-254 -333C-254 -333 -186 72 278 199C742 326 810 731 810 731",
                "M-247 -341C-247 -341 -179 64 285 191C749 318 817 723 817 723",
                "M-240 -349C-240 -349 -172 56 292 183C756 310 824 715 824 715",
                "M-233 -357C-233 -357 -165 48 299 175C763 302 831 707 831 707",
                "M-226 -365C-226 -365 -158 40 306 167C770 294 838 699 838 699",
                "M-219 -373C-219 -373 -151 32 313 159C777 286 845 691 845 691",
                "M-212 -381C-212 -381 -144 24 320 151C784 278 852 683 852 683",
                "M-205 -389C-205 -389 -137 16 327 143C791 270 859 675 859 675",
                "M-198 -397C-198 -397 -130 8 334 135C798 262 866 667 866 667",
                "M-191 -405C-191 -405 -123 0 341 127C805 254 873 659 873 659",
                "M-184 -413C-184 -413 -116 -8 348 119C812 246 880 651 880 651",
                "M-177 -421C-177 -421 -109 -16 355 111C819 238 887 643 887 643",
                "M-170 -429C-170 -429 -102 -24 362 103C826 230 894 635 894 635",
                "M-163 -437C-163 -437 -95 -32 369 95C833 222 901 627 901 627",
                "M-156 -445C-156 -445 -88 -40 376 87C840 214 908 619 908 619",
                "M-149 -453C-149 -453 -81 -48 383 79C847 206 915 611 915 611",
                "M-142 -461C-142 -461 -74 -56 390 71C854 198 922 603 922 603",
                "M-135 -469C-135 -469 -67 -64 397 63C861 190 929 595 929 595",
                "M-128 -477C-128 -477 -60 -72 404 55C868 182 936 587 936 587",
                "M-121 -485C-121 -485 -53 -80 411 47C875 174 943 579 943 579",
                "M-114 -493C-114 -493 -46 -88 418 39C882 166 950 571 950 571",
                "M-107 -501C-107 -501 -39 -96 425 31C889 158 957 563 957 563",
                "M-100 -509C-100 -509 -32 -104 432 23C896 150 964 555 964 555",
                "M-93 -517C-93 -517 -25 -112 439 15C903 142 971 547 971 547",
                "M-86 -525C-86 -525 -18 -120 446 7C910 134 978 539 978 539",
                "M-79 -533C-79 -533 -11 -128 453 -1C917 126 985 531 985 531",
                "M-72 -541C-72 -541 -4 -136 460 -9C924 118 992 523 992 523",
                "M-65 -549C-65 -549 3 -144 467 -17C931 110 999 515 999 515",
                "M-58 -557C-58 -557 10 -152 474 -25C938 102 1006 507 1006 507",
                "M-51 -565C-51 -565 17 -160 481 -33C945 94 1013 499 1013 499",
                "M-44 -573C-44 -573 24 -168 488 -41C952 86 1020 491 1020 491",
                "M-37 -581C-37 -581 31 -176 495 -49C959 78 1027 483 1027 483"
            ], []);

            // Pre-calculate random values for consistent animation
            const animationConfigs = useMemo(() => 
                paths.map((_, index) => ({
                    y2End: 93 + (index * 0.3) % 8, // Consistent but varied end position
                    duration: 12 + (index % 8), // Consistent but varied duration
                    delay: index * 0.05, // Staggered start for wave effect
                })), []
            );

            return (
                <div className={`beams-container ${className || ''}`}>
                    <svg
                        className="beams-svg"
                        width="100%"
                        height="100%"
                        viewBox="0 0 696 316"
                        fill="none"
                        xmlns="http://www.w3.org/2000/svg"
                    >
                        <path
                            d="M-380 -189C-380 -189 -312 216 152 343C616 470 684 875 684 875M-373 -197C-373 -197 -305 208 159 335C623 462 691 867 691 867M-366 -205C-366 -205 -298 200 166 327C630 454 698 859 698 859M-359 -213C-359 -213 -291 192 173 319C637 446 705 851 705 851M-352 -221C-352 -221 -284 184 180 311C644 438 712 843 712 843M-345 -229C-345 -229 -277 176 187 303C651 430 719 835 719 835M-338 -237C-338 -237 -270 168 194 295C658 422 726 827 726 827M-331 -245C-331 -245 -263 160 201 287C665 414 733 819 733 819M-324 -253C-324 -253 -256 152 208 279C672 406 740 811 740 811M-317 -261C-317 -261 -249 144 215 271C679 398 747 803 747 803M-310 -269C-310 -269 -242 136 222 263C686 390 754 795 754 795M-303 -277C-303 -277 -235 128 229 255C693 382 761 787 761 787M-296 -285C-296 -285 -228 120 236 247C700 374 768 779 768 779M-289 -293C-289 -293 -221 112 243 239C707 366 775 771 775 771M-282 -301C-282 -301 -214 104 250 231C714 358 782 763 782 763M-275 -309C-275 -309 -207 96 257 223C721 350 789 755 789 755M-268 -317C-268 -317 -200 88 264 215C728 342 796 747 796 747M-261 -325C-261 -325 -193 80 271 207C735 334 803 739 803 739M-254 -333C-254 -333 -186 72 278 199C742 326 810 731 810 731M-247 -341C-247 -341 -179 64 285 191C749 318 817 723 817 723M-240 -349C-240 -349 -172 56 292 183C756 310 824 715 824 715M-233 -357C-233 -357 -165 48 299 175C763 302 831 707 831 707M-226 -365C-226 -365 -158 40 306 167C770 294 838 699 838 699M-219 -373C-219 -373 -151 32 313 159C777 286 845 691 845 691M-212 -381C-212 -381 -144 24 320 151C784 278 852 683 852 683M-205 -389C-205 -389 -137 16 327 143C791 270 859 675 859 675M-198 -397C-198 -397 -130 8 334 135C798 262 866 667 866 667M-191 -405C-191 -405 -123 0 341 127C805 254 873 659 873 659M-184 -413C-184 -413 -116 -8 348 119C812 246 880 651 880 651M-177 -421C-177 -421 -109 -16 355 111C819 238 887 643 887 643M-170 -429C-170 -429 -102 -24 362 103C826 230 894 635 894 635M-163 -437C-163 -437 -95 -32 369 95C833 222 901 627 901 627M-156 -445C-156 -445 -88 -40 376 87C840 214 908 619 908 619M-149 -453C-149 -453 -81 -48 383 79C847 206 915 611 915 611M-142 -461C-142 -461 -74 -56 390 71C854 198 922 603 922 603M-135 -469C-135 -469 -67 -64 397 63C861 190 929 595 929 595M-128 -477C-128 -477 -60 -72 404 55C868 182 936 587 936 587M-121 -485C-121 -485 -53 -80 411 47C875 174 943 579 943 579M-114 -493C-114 -493 -46 -88 418 39C882 166 950 571 950 571M-107 -501C-107 -501 -39 -96 425 31C889 158 957 563 957 563M-100 -509C-100 -509 -32 -104 432 23C896 150 964 555 964 555M-93 -517C-93 -517 -25 -112 439 15C903 142 971 547 971 547M-86 -525C-86 -525 -18 -120 446 7C910 134 978 539 978 539M-79 -533C-79 -533 -11 -128 453 -1C917 126 985 531 985 531M-72 -541C-72 -541 -4 -136 460 -9C924 118 992 523 992 523M-65 -549C-65 -549 3 -144 467 -17C931 110 999 515 999 515M-58 -557C-58 -557 10 -152 474 -25C938 102 1006 507 1006 507M-51 -565C-51 -565 17 -160 481 -33C945 94 1013 499 1013 499M-44 -573C-44 -573 24 -168 488 -41C952 86 1020 491 1020 491M-37 -581C-37 -581 31 -176 495 -49C959 78 1027 483 1027 483"
                            stroke="url(#paint0_radial_242_278)"
                            strokeOpacity="0.05"
                            strokeWidth="0.5"
                        ></path>

                        {paths.map((path, index) => (
                            <motion.path
                                key={`path-` + index}
                                d={path}
                                stroke={`url(#linearGradient-${index})`}
                                strokeOpacity="0.4"
                                strokeWidth="0.5"
                            ></motion.path>
                        ))}
                        <defs>
                            {paths.map((path, index) => {
                                const config = animationConfigs[index];
                                return (
                                    <motion.linearGradient
                                        id={`linearGradient-${index}`}
                                        key={`gradient-${index}`}
                                        initial={{
                                            x1: "0%",
                                            x2: "0%",
                                            y1: "0%",
                                            y2: "0%",
                                        }}
                                        animate={{
                                            x1: ["0%", "100%"],
                                            x2: ["0%", "95%"],
                                            y1: ["0%", "100%"],
                                            y2: ["0%", `${config.y2End}%`],
                                        }}
                                        transition={{
                                            duration: config.duration,
                                            ease: "linear",
                                            repeat: Infinity,
                                            delay: config.delay,
                                        }}
                                    >
                                        <stop stopColor="#18CCFC" stopOpacity="0"></stop>
                                        <stop stopColor="#18CCFC"></stop>
                                        <stop offset="32.5%" stopColor="#6344F5"></stop>
                                        <stop offset="100%" stopColor="#AE48FF" stopOpacity="0"></stop>
                                    </motion.linearGradient>
                                );
                            })}

                            <radialGradient
                                id="paint0_radial_242_278"
                                cx="0"
                                cy="0"
                                r="1"
                                gradientUnits="userSpaceOnUse"
                                gradientTransform="translate(352 34) rotate(90) scale(555 1560.62)"
                            >
                                <stop offset="0.0666667" stopColor="#d4d4d4"></stop>
                                <stop offset="0.243243" stopColor="#d4d4d4"></stop>
                                <stop offset="0.43594" stopColor="white" stopOpacity="0"></stop>
                            </radialGradient>
                        </defs>
                    </svg>
                </div>
            );
        });

        // Render the background beams
        const beamsRoot = ReactDOM.createRoot(document.getElementById('beams-container'));
        beamsRoot.render(<BackgroundBeams />);
    </script>

    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script>
        // Main application
        document.addEventListener('DOMContentLoaded', () => {
            // Scene setup
            const container = document.getElementById('canvas-container');
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            // Check if mobile
            const isMobile = window.innerWidth < 768;
            
            // Scene
            const scene = new THREE.Scene();
            
            // Camera
            const camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 1000);
            camera.position.set(0, 0, 7);
            
            // Renderer
            const renderer = new THREE.WebGLRenderer({ antialias: isMobile ? false : true, alpha: true });
            renderer.setSize(width, height);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = !isMobile;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            container.appendChild(renderer.domElement);
            
            // Enhanced lighting setup
            const ambientLight = new THREE.AmbientLight(0x101010, 0.1);
            scene.add(ambientLight);
            
            // Main spotlight from the right - extremely intense and visible
            const mainSpotLight = new THREE.SpotLight(0xffffff, 5.0, 30, Math.PI / 3, 0.2, 1);
            mainSpotLight.position.set(12, 0, 0);
            mainSpotLight.target.position.set(0, 0, 0);
            mainSpotLight.castShadow = !isMobile;
            if (!isMobile) {
                mainSpotLight.shadow.mapSize.width = 2048;
                mainSpotLight.shadow.mapSize.height = 2048;
                mainSpotLight.shadow.bias = -0.0001;
                mainSpotLight.shadow.camera.near = 0.5;
                mainSpotLight.shadow.camera.far = 30;
            }
            scene.add(mainSpotLight);
            scene.add(mainSpotLight.target);
            
            // Additional fill light from left - very soft
            const fillLight = new THREE.DirectionalLight(0x202020, 0.2);
            fillLight.position.set(-10, 1, 1);
            scene.add(fillLight);
            
            // Right side light - bright and warm
            const rightLight = new THREE.DirectionalLight(0xffffff, 1.5);
            rightLight.position.set(15, 2, 0);
            scene.add(rightLight);
            
            // Animated light source that gradually becomes lighter
            const animatedLight = new THREE.PointLight(0xffffff, 0.5, 20);
            animatedLight.position.set(8, 0, 5);
            scene.add(animatedLight);
            
            // Animation variables for the light
            let lightIntensity = 0.5;
            let lightDirection = 1; // 1 for increasing, -1 for decreasing
            const maxIntensity = 3.0;
            const minIntensity = 0.5;
            
            // Top light for better illumination
            const topLight = new THREE.PointLight(0xffffff, 1.0, 25);
            topLight.position.set(0, 12, 0);
            scene.add(topLight);
            
            // Cube parameters with increased gap
            const CUBE_SIZE = 0.65;
            const GAP = 0.12; // Even larger gap for better light visibility
            const RADIUS = 0.075;
            const ANIMATION_DURATION = 1.2;
            
            // Enhanced materials - blackish with carved corners effect
            const chromeMaterial = new THREE.MeshPhysicalMaterial({
                color: 0x0a0a0a,
                metalness: 0.9,
                roughness: 0.1,
                clearcoat: 0.5,
                clearcoatRoughness: 0.05,
                reflectivity: 0.9,
                envMapIntensity: 2.0
            });
            
            // Cube class
            class RubiksCube {
                constructor() {
                    this.group = new THREE.Group();
                    this.cubes = [];
                    this.isAnimating = false;
                    this.currentRotation = 0;
                    this.lastMoveAxis = null;
                    this.currentMove = null;
                    this.animationFrame = null;
                    this.isMounted = true;
                    this.isResizing = false;
                    this.resizeTimeout = null;
                    this.smoothness = isMobile ? 2 : 4;
                    this.castShadow = !isMobile;
                    this.receiveShadow = !isMobile;
                    
                    this.initializeCubes();
                    this.setupEventListeners();
                }
                
                initializeCubes() {
                    const positions = [-1, 0, 1];
                    
                    for (let x of positions) {
                        for (let y of positions) {
                            for (let z of positions) {
                                const cubeGroup = new THREE.Group();
                                cubeGroup.position.set(
                                    x * (CUBE_SIZE + GAP),
                                    y * (CUBE_SIZE + GAP),
                                    z * (CUBE_SIZE + GAP)
                                );
                                
                                // Create carved corner effect with smaller geometry
                                const geometry = new THREE.BoxGeometry(CUBE_SIZE, CUBE_SIZE, CUBE_SIZE);
                                const edges = new THREE.EdgesGeometry(geometry);
                                const line = new THREE.LineSegments(
                                    edges,
                                    new THREE.LineBasicMaterial({ 
                                        color: 0x333333, 
                                        transparent: true, 
                                        opacity: 0.6,
                                        linewidth: 1
                                    })
                                );
                                
                                const cube = new THREE.Mesh(geometry, chromeMaterial);
                                cube.castShadow = this.castShadow;
                                cube.receiveShadow = this.receiveShadow;
                                
                                cubeGroup.add(cube);
                                cubeGroup.add(line);
                                this.group.add(cubeGroup);
                                
                                this.cubes.push({
                                    group: cubeGroup,
                                    position: new THREE.Vector3(x, y, z),
                                    originalCoords: { x, y, z },
                                    id: `cube-${x}-${y}-${z}`
                                });
                            }
                        }
                    }
                    
                    scene.add(this.group);
                }
                
                reset() {
                    if (!this.isMounted) return;
                    
                    this.group.rotation.set(0, 0, 0);
                    this.isAnimating = false;
                    this.currentRotation = 0;
                    this.lastMoveAxis = null;
                    this.currentMove = null;
                    
                    if (this.animationFrame) {
                        cancelAnimationFrame(this.animationFrame);
                        this.animationFrame = null;
                    }
                    
                    // Remove all cubes
                    while (this.group.children.length > 0) {
                        this.group.remove(this.group.children[0]);
                    }
                    
                    this.cubes = [];
                    this.initializeCubes();
                }
                
                setupEventListeners() {
                    window.addEventListener('resize', this.handleResize.bind(this));
                    window.addEventListener('orientationchange', this.handleOrientationChange.bind(this));
                    document.addEventListener('visibilitychange', this.handleVisibilityChange.bind(this));
                }
                
                handleResize() {
                    if (!this.isMounted) return;
                    
                    this.isResizing = true;
                    
                    if (this.resizeTimeout) {
                        clearTimeout(this.resizeTimeout);
                    }
                    
                    this.resizeTimeout = setTimeout(() => {
                        if (!this.isMounted) return;
                        
                        const width = window.innerWidth;
                        const height = window.innerHeight;
                        
                        camera.aspect = width / height;
                        camera.updateProjectionMatrix();
                        renderer.setSize(width, height);
                        
                        const newIsMobile = width < 768;
                        if (newIsMobile !== isMobile) {
                            this.smoothness = newIsMobile ? 2 : 4;
                            this.castShadow = !newIsMobile;
                            this.receiveShadow = !newIsMobile;
                            
                            // Update all cubes' shadow properties
                            this.cubes.forEach(cube => {
                                cube.group.traverse(child => {
                                    if (child.isMesh) {
                                        child.castShadow = this.castShadow;
                                        child.receiveShadow = this.receiveShadow;
                                    }
                                });
                            });
                            
                            renderer.shadowMap.enabled = !newIsMobile;
                        }
                        
                        this.isResizing = false;
                    }, 150);
                }
                
                handleOrientationChange() {
                    if (this.isAnimating) {
                        this.reset();
                    }
                    setTimeout(this.handleResize.bind(this), 100);
                }
                
                handleVisibilityChange() {
                    if (!this.isMounted) return;
                    
                    const isPageVisible = document.visibilityState === "visible";
                    
                    if (!isPageVisible) {
                        this.reset();
                    } else {
                        setTimeout(() => {
                            if (this.isMounted) {
                                this.handleResize();
                            }
                        }, 100);
                    }
                }
                
                isInLayer(position, axis, layer) {
                    const coord = axis === "x" ? position.x : axis === "y" ? position.y : position.z;
                    return Math.abs(coord - layer) < 0.1;
                }
                
                getPossibleMoves() {
                    const moves = [];
                    for (let axis of ['x', 'y', 'z']) {
                        for (let layer of [-1, 0, 1]) {
                            for (let direction of [1, -1]) {
                                moves.push({ axis, layer, direction });
                            }
                        }
                    }
                    return moves;
                }
                
                selectNextMove() {
                    if (!this.isAnimating && this.isMounted && !this.isResizing) {
                        const possibleMoves = this.getPossibleMoves();
                        const availableMoves = possibleMoves.filter(
                            (move) => move.axis !== this.lastMoveAxis
                        );
                        
                        if (availableMoves.length === 0) {
                            // If no available moves (shouldn't happen), reset and try again
                            this.reset();
                            setTimeout(() => this.selectNextMove(), 500);
                            return;
                        }
                        
                        const move = availableMoves[Math.floor(Math.random() * availableMoves.length)];
                        const rotationAngle = Math.PI / 2;
                        
                        this.currentMove = { ...move, rotationAngle };
                        this.lastMoveAxis = move.axis;
                        this.isAnimating = true;
                        this.currentRotation = 0;
                    }
                }
                
                scheduleNextMove() {
                    if (!this.isMounted || this.isResizing) return;
                    
                    const delay = this.isAnimating ? ANIMATION_DURATION * 1000 : 200;
                    
                    setTimeout(() => {
                        this.selectNextMove();
                        if (this.isMounted) {
                            this.scheduleNextMove();
                        }
                    }, delay);
                }
                
                createRotationMatrix(axis, angle) {
                    const matrix = new THREE.Matrix4();
                    const quaternion = new THREE.Quaternion();
                    const vector = new THREE.Vector3();
                    
                    vector.set(0, 0, 0);
                    vector[axis] = 1;
                    quaternion.setFromAxisAngle(vector, angle);
                    return matrix.makeRotationFromQuaternion(quaternion);
                }
                
                easeInOutQuad(t) {
                    return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
                }
                
                updateCubes(move, stepRotationMatrix) {
                    this.cubes.forEach(cube => {
                        if (this.isInLayer(cube.position, move.axis, move.layer)) {
                            // Update position
                            const newPosition = cube.position.clone().applyMatrix4(stepRotationMatrix);
                            cube.position.copy(newPosition);
                            
                            // Update rotation - create a new rotation matrix for the cube
                            const cubeRotationMatrix = new THREE.Matrix4().extractRotation(cube.group.matrix);
                            const newRotationMatrix = new THREE.Matrix4().multiplyMatrices(
                                stepRotationMatrix,
                                cubeRotationMatrix
                            );
                            
                            const newQuaternion = new THREE.Quaternion().setFromRotationMatrix(newRotationMatrix);
                            cube.group.quaternion.copy(newQuaternion);
                            
                            // Update group position
                            cube.group.position.set(
                                cube.position.x * (CUBE_SIZE + GAP),
                                cube.position.y * (CUBE_SIZE + GAP),
                                cube.position.z * (CUBE_SIZE + GAP)
                            );
                        }
                    });
                }
                
                normalizePositions() {
                    this.cubes.forEach(cube => {
                        const x = Math.round(cube.position.x);
                        const y = Math.round(cube.position.y);
                        const z = Math.round(cube.position.z);
                        
                        cube.position.set(x, y, z);
                        
                        // Update group position to match
                        cube.group.position.set(
                            x * (CUBE_SIZE + GAP),
                            y * (CUBE_SIZE + GAP),
                            z * (CUBE_SIZE + GAP)
                        );
                    });
                }
                
                checkCubeIntegrity() {
                    if (this.cubes.length !== 27) {
                        console.warn("Incorrect number of cubes:", this.cubes.length);
                        return false;
                    }

                    for (const cube of this.cubes) {
                        const { x, y, z } = cube.position;
                        if (Math.abs(x) > 1.1 || Math.abs(y) > 1.1 || Math.abs(z) > 1.1) {
                            console.warn("Cube out of range:", cube.id, x, y, z);
                            return false;
                        }
                    }
                    
                    return true;
                }
                
                update(delta) {
                    // Rotate the entire cube slowly
                    this.group.rotation.x += delta * 0.3;
                    this.group.rotation.y += delta * 0.5;
                    this.group.rotation.z += delta * 0.2;
                    
                    // Animate the light intensity
                    lightIntensity += delta * 0.5 * lightDirection;
                    if (lightIntensity >= maxIntensity) {
                        lightIntensity = maxIntensity;
                        lightDirection = -1;
                    } else if (lightIntensity <= minIntensity) {
                        lightIntensity = minIntensity;
                        lightDirection = 1;
                    }
                    animatedLight.intensity = lightIntensity;
                    
                    if (this.isResizing && this.isAnimating) {
                        this.reset();
                        return;
                    }
                    
                    if (this.isAnimating && this.currentMove) {
                        const move = this.currentMove;
                        const targetRotation = move.rotationAngle;
                        const rotation = delta / ANIMATION_DURATION;
                        
                        if (this.currentRotation < 1) {
                            const newRotation = Math.min(this.currentRotation + rotation, 1);
                            const prevRotation = this.currentRotation;
                            this.currentRotation = newRotation;
                            
                            const easedProgress = this.easeInOutQuad(newRotation);
                            const prevEasedProgress = this.easeInOutQuad(prevRotation);
                            const currentAngle = easedProgress * targetRotation;
                            const prevAngle = prevEasedProgress * targetRotation;
                            const stepRotation = currentAngle - prevAngle;
                            
                            const stepRotationMatrix = this.createRotationMatrix(
                                move.axis,
                                stepRotation * move.direction
                            );
                            
                            this.updateCubes(move, stepRotationMatrix);
                            
                            if (newRotation >= 1) {
                                this.normalizePositions();
                                
                                if (!this.checkCubeIntegrity()) {
                                    console.warn("Cube integrity check failed, resetting...");
                                    setTimeout(() => this.reset(), 0);
                                    return;
                                }
                                
                                this.isAnimating = false;
                                this.currentRotation = 0;
                                this.currentMove = null;
                            }
                        }
                    }
                }
            }
            
            // Create the Rubik's Cube
            const rubiksCube = new RubiksCube();
            rubiksCube.scheduleNextMove();
            
            // Animation loop
            const animate = () => {
                requestAnimationFrame(animate);
                
                const delta = Math.min(clock.getDelta(), 0.1); // Cap delta to prevent large jumps
                rubiksCube.update(delta);
                
                renderer.render(scene, camera);
            };
            
            const clock = new THREE.Clock();
            animate();
            
            // Cleanup on unmount
            window.addEventListener('beforeunload', () => {
                rubiksCube.isMounted = false;
                if (rubiksCube.animationFrame) {
                    cancelAnimationFrame(rubiksCube.animationFrame);
                }
                if (rubiksCube.resizeTimeout) {
                    clearTimeout(rubiksCube.resizeTimeout);
                }
                
                // Remove all event listeners
                window.removeEventListener('resize', rubiksCube.handleResize);
                window.removeEventListener('orientationchange', rubiksCube.handleOrientationChange);
                document.removeEventListener('visibilitychange', rubiksCube.handleVisibilityChange);
                
                // Clean up Three.js objects
                scene.remove(rubiksCube.group);
                while (scene.children.length > 0) {
                    scene.remove(scene.children[0]);
                }
                
                if (renderer.domElement.parentNode) {
                    renderer.domElement.parentNode.removeChild(renderer.domElement);
                }
                
                renderer.dispose();
            });
        });
    </script>
</body>
</html>